<!DOCTYPE html>
<html lang="hu">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Nyelvtanul√≥</title>

<style>
body {
  font-family: -apple-system, BlinkMacSystemFont, sans-serif;
  padding: 20px;
}
input, textarea, select, button {
  width: 100%;
  padding: 12px;
  margin-top: 8px;
  font-size: 16px;
}
textarea { height: 100px; }
button {
  background: #007AFF;
  color: white;
  border: none;
  border-radius: 8px;
}
.controls button {
  margin-top: 10px;
}
.section {
  margin-top: 25px;
  padding-top: 10px;
  border-top: 1px solid #ccc;
}
.wordlist div {
  font-size: 14px;
}
</style>
</head>

<body>

<h2>üìÅ Sz√≥csoportok</h2>
<input id="newGroup" placeholder="√öj sz√≥csoport neve">
<button onclick="addGroup()">Sz√≥csoport l√©trehoz√°sa</button>
<select id="groupSelect"></select>

<div class="section">
<h3>‚ûï Egy sz√≥</h3>
<input id="singleForeign" placeholder="Idegen sz√≥">
<input id="singleHu" placeholder="Magyar jelent√©s">
<button onclick="addSingleWord()">Hozz√°ad√°s</button>
</div>

<div class="section">
<h3>üìã T√∂meges bevitel</h3>
<textarea id="bulkInput" placeholder="andare - menni"></textarea>
<button onclick="addBulkWords()">Hozz√°ad√°s</button>
</div>

<div class="section">
<h3>‚ñ∂Ô∏è Lej√°tsz√°s</h3>
<input id="delay" type="number" value="3" placeholder="Sz√ºnet (mp)">
<input id="repeat" type="number" value="3" placeholder="Ism√©tl√©s">
<div class="controls">
<button onclick="startPlayback()">START</button>
<button onclick="pausePlayback()">PAUSE</button>
<button onclick="resumePlayback()">RESUME</button>
<button onclick="stopPlayback()">STOP</button>
</div>
</div>

<script>
let data = JSON.parse(localStorage.getItem("wordGroups") || "{}");
let playing = false;
let paused = false;
let audioCtx, leftGain, rightGain, noise;

function save() {
  localStorage.setItem("wordGroups", JSON.stringify(data));
}

function addGroup() {
  const n = newGroup.value.trim();
  if (!n || data[n]) return;
  data[n] = [];
  save();
  refreshGroups();
}

function refreshGroups() {
  groupSelect.innerHTML = "";
  Object.keys(data).forEach(g => {
    const o = document.createElement("option");
    o.value = g; o.textContent = g;
    groupSelect.appendChild(o);
  });
}
refreshGroups();

function currentGroup() {
  return groupSelect.value;
}

function addSingleWord() {
  if (!currentGroup()) return;
  data[currentGroup()].push({
    foreign: singleForeign.value.trim(),
    hu: singleHu.value.trim()
  });
  save();
  singleForeign.value = singleHu.value = "";
}

function addBulkWords() {
  if (!currentGroup()) return;
  bulkInput.value.split("\n").forEach(l => {
    const p = l.split(/[-=‚Äì\t]/);
    if (p.length >= 2) {
      data[currentGroup()].push({ foreign: p[0].trim(), hu: p.slice(1).join("-").trim() });
    }
  });
  bulkInput.value = "";
  save();
}

function initAudio() {
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const buffer = audioCtx.createBuffer(1, audioCtx.sampleRate * 2, audioCtx.sampleRate);
  const d = buffer.getChannelData(0);
  for (let i = 0; i < d.length; i++) d[i] = (Math.random()*2-1)*0.05;

  noise = audioCtx.createBufferSource();
  noise.buffer = buffer;
  noise.loop = true;

  leftGain = audioCtx.createGain();
  rightGain = audioCtx.createGain();
  leftGain.gain.value = 0.15;
  rightGain.gain.value = 0.05;

  const split = audioCtx.createChannelSplitter(2);
  const merge = audioCtx.createChannelMerger(2);

  noise.connect(split);
  split.connect(leftGain,0);
  split.connect(rightGain,0);
  leftGain.connect(merge,0,0);
  rightGain.connect(merge,0,1);
  merge.connect(audioCtx.destination);
  noise.start();
}

function focusLeft() {
  leftGain.gain.setTargetAtTime(0.18,audioCtx.currentTime,1);
  rightGain.gain.setTargetAtTime(0.03,audioCtx.currentTime,1);
}
function focusRight() {
  leftGain.gain.setTargetAtTime(0.03,audioCtx.currentTime,1);
  rightGain.gain.setTargetAtTime(0.18,audioCtx.currentTime,1);
}

function speak(text, lang) {
  return new Promise(res => {
    const u = new SpeechSynthesisUtterance(text);
    u.lang = lang;
    u.onend = res;
    speechSynthesis.speak(u);
  });
}

function wait(sec) {
  return new Promise(async r => {
    while (paused) await new Promise(x=>setTimeout(x,200));
    setTimeout(r, sec*1000);
  });
}

async function startPlayback() {
  if (!currentGroup()) return;
  playing = true; paused = false;
  if (!audioCtx) initAudio();
  await audioCtx.resume();

  const words = data[currentGroup()];
  const delay = Number(delayInput.value || delay.value);
  const repeat = Number(repeatInput?.value || repeat.value);

  for (let w of words) {
    if (!playing) break;
    for (let i=0;i<repeat;i++) {
      focusLeft();
      await speak(w.foreign,"it-IT");
      await wait(delay);
      focusRight();
      await speak(w.hu,"hu-HU");
      await wait(delay);
    }
    for (let i=0;i<repeat;i++) {
      focusRight();
      await speak(w.foreign,"it-IT");
      await wait(delay);
      focusLeft();
      await speak(w.hu,"hu-HU");
      await wait(delay);
    }
  }
}

function pausePlayback() {
  paused = true;
  speechSynthesis.pause();
}
function resumePlayback() {
  paused = false;
  speechSynthesis.resume();
}
function stopPlayback() {
  playing = false;
  paused = false;
  speechSynthesis.cancel();
}
</script>

</body>
</html>
